给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。
例如，我们从6767开始，将得到7766 - 6677 = 1089\ 9810 - 0189 = 9621\ 9621 - 1269 = 8352\ 8532 - 2358 = 6174\ 7641 - 1467 = 6174\ ... ...

现给定任意4位正整数，请编写程序演示到达黑洞的过程。

输入格式：
输入给出一个(0, 10000)区间内的正整数N。
输出格式：
如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。

输入样例1：
6767
输出样例1：
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
输入样例2：
2222
输出样例2：
2222 - 2222 = 0000

code:

#include <iostream>
#include <algorithm>
using namespace std;
bool cmpd(int a, int b) {return a > b;}
bool cmpu(int a, int b) {return a < b;}
int main() {
	int n;
	cin >> n;
	int a[4];
	for (int i = 0; i < 4; i++) {
		a[i] = n % 10;
		n /= 10;
	}
	if (a[0] == a[1] && a[0]== a[2] && a[0] == a[3]) {
		printf("%d%d%d%d - %d%d%d%d = 0000", a[0], a[1], a[2], a[3], a[0], a[1], a[2], a[3]);
	}
	else {
		while (1) {
			sort(a, a + 4, cmpd);
			int x = a[0], y = a[1], z = a[2], t = a[3];
			printf("%d%d%d%d - ", x,y,z,t);
			sort(a, a + 4, cmpu);
			int b = a[0], c = a[1], d = a[2], e = a[3];
			printf("%d%d%d%d ",b,c,d,e);
			int q = (x * 1000 + y * 100 + z * 10 + t) - (b * 1000 + c * 100 + d * 10 + e);
			printf("= %04d\n", q);
			if (q == 6174)break;
			a[0] = q / 1000; q %=1000;
			a[1] = q / 100; q %=100;
			a[2] = q / 10; q%=10;
			a[3] = q; 
		}
	}
	return 0;
}
